* Components

** Navbars

*** Defining Navbar Items

    A navbar consists of a number of elements (brand, menus etc). To assist in
    defining these elements, the function ~defnavbar-item~ is provided. This
    function generates a map which the ~navbar~ component knows how to process
    in order to generate the HTML and Javascript for the component. 

    A navbar item is a map which can contain the following keys. The only
    required keys are ~:type~ and ~:contents~. 

    - :type :: The type of the item. Valid types are
	- *:a* Item contents are wrapped in an ~<a>~ element. Default
	- *:div* Item contents are wrapped in a ~<div>~ element
	- *:dropdown* Item contents represent a dropdown menu and are wrapped
          as a dropdown menu element
	- *:raw* Item contents are not wrapped in any elmeent. Just added 'as
          is'.


    - :title :: The title to use for dropdown menus (i.e. parent menu title)
    - :class :: Any additional classes to add to the element i.e. tweak CSS
      styles.
    - :href :: For link elements, the ~href~ target. Defaults to ~#~
    - :id :: Element Id. If not specified, a unique Id will be automatically
      generated with the prefix ~nav-~
    - :contents :: The item content. The value of this key will depend on the
      type of item.
	- *:a* The anchor text
	- *:raw* Value is simply wrapped in a ~<div>~ element
	- *:div* Vector of item maps generated by ~defnavbar-item~
	- *:dropdown* Vecotr of item maps defining dropdown menu items
          generated by ~defnavbar-item~.


    - :selectable :: True if the item should have a click handler associated
      with it. Default is true.
    - :icon-image :: Local path to an icon image to be added to the item
    - :is-hoverable :: For dropdown menus, adds the hoverable class to enable
      the menu to dropdown when mouse hovers over parent link 

*** The Navbar Component

   The navbar is an application navigaton bar to appear at the top of the
   rendered page. It consists of an (pitonal) brand and application menus and 
   possibly other items, such as a search box or static text. the navbar can be
   definined to have a shadow effect and be either a light or dark colour. A
   /burger/ menus is also supported, which will be displayed on mobile and table
   screens. Clicking the burger will then list the menus vertically on small
   screen devices. 

   When a navbar menu choice is made, the ~id~ of the chosen item is put into
   the session state atom under the key ~:choice~ within the map referenced by
   the ~:sesson-key~ value. 

   Menus can be regular single item menu links or dropdown menus. The function
   ~defnavbar-item` can be used to define menu items. 

   The basic idea behind the navbar is that it can be defined as pure data, in a
   map which consists of the following keys.

   - :session-key :: this is a path into the session state atom and used by the
     navbar component to record /public/ information which may be used by other
     pats of the application e.g. menu choices, current page etc. The global
     session state is managed by the ~reagent-session~ library.
   - :has-shadow :: True if the navbar should have a shadow effect. Defaults to
     true
   - :is-dark :: True if the navbar should be rendered in a dark colour. False
     by default
   - :has-burger :: True if the navbar has a burger menu which is displayed on
     small screens. Default is true.
   - :class :: Additional classes to add to the ~<nav>~ element
   - :default-link :: The Id of the defualt menu link to mark as active when the
     navbar is first loaded
   - :brand :: A map created by ~defnavbar-item~ representing the navbar brand
     element
   - :menus :: A vector of ~defnavbar-item~ maps representing the main menu
     elements
   - :end-menu :: A vector of ~defnavbar-item~ items defining menus to be added
     to the right of the main menus in the navbar 

*** Example Navbar

    An exmaple navbar 

    #+begin_src clojure
      (ns example.app.core
	(:require [bulmaBook.components.navbar :refer :all]))

      (def navbar-data
	{:session-key [:main-navbar]
	 :has-shadow true
	 :class "is-dark"
	 :default-link :home
	 :has-burger true
	 :brand (defnavbar-item
		  :contents [:img {:src "images/logo.png"}])
	 :menus [(defnavbar-item
		   :type :div
		   :contents
		   [(defnavbar-item
		      :type :raw
		      :contents [:small "Publishing at the speed of technology"])])
		 (defnavbar-item
		   :contents "Home"
		   :id :home)]
	 :end-menu [(defnavbar-item
		      :type :dropdown
		      :title "Alex Johnson"
		      :is-hoverable true
		      :contents [(defnavbar-item :id :profile :contents "Profile"
				   :icon-img "fa-user-circle-o")
				 (defnavbar-item :id :report-bug
				   :contents "Report Bug" :icon-img "fa-bug")
				 (defnavbar-item :id :sign-out :contents "Sign Out"
				   :icon-img "fa-sign-out")])]})

      (navbar navbar-data)

    #+end_src

** Page pagination

   The ~paginate~ component provides a simple pagination function to help
   display long lists of records. Records will be partitioned into groups of
   /pages/ with a simple navigation header allowing movement forward/back and
   selection of specific pages from the list. 

   The component has two mandatory arguments, ~records~ and ~page-render-fn~ and
   three optional named arguments.

   - records :: A sequence of individual records to be displayed in the pages
   - page-render-fn :: The function used to display each record. I should accept
     one argument, the record to display. This is typically a ~Reagent~
     component used to render the record.
   - :page-size :: The number of records to display on each page. Default 10.
   - :is-rounded :: If true, navigation elements have rounded corners. Default
     false
   - :button-size :: Set the size of navigation buttons. May be ~:small~,
     ~:medium~ or ~:large~.

*** Example

    Example of simple pagination.

    #+begin_src clojure
      (ns example.app.core
	(:require [bulmaBook.components.paginate :refer :all]))

      (def data [{:title "TensorFlow For Machine Intelligence"
		  :image "images/tensorflow.jpg"
		  :cost "$22.99"
		  :pages 270
		  :isbn "9781939902351"}
		 {:title "Docker in Production"
		  :image "images/docker.jpg"
		  :cost "$22.99"
		  :pages 156
		  :isbn "9781939902184"}
		 {:title "Developing a Gulp.js Edge"
		  :image "images/gulp.jpg"
		  :cost "$22.99"
		  :pages 134
		  :isbn "9781939902146"}
		 {:title "Learning Swift”"
		  :image "images/swift.jpg"
		  :cost "$22.99"
		  :pages 342
		  :isbn "9781939902115"}
		 {:title "Choosing a JavaScript Framework"
		  :image "images/js-framework.jpg"
		  :cost "19.99"
		  :pages 96
		  :isbn "9781939902092"}
		 {:title "Deconstructing Google Cardboard Apps"
		  :image "images/google-cardboard.jpg"
		  :cost "$22.99"
		  :pages 179
		  :isbn "9781939902092245"}])

      (defn book-component [book]
	[:article.box
	 [media {:content [[:p.title.is-5.is-spaced.is-marginless
			    [:a {:href "#"} (:title book)]]
			   [:p.subtitle.is-marginless (:price book)]
			   [:div.content.is-small
			    (str (:pages book) " pages")
			    [:br]
			    (str "ISBN: " (:isbn book))
			    [:br]
			    [:a {:href "#"} "Edit"]
			    [:span "·"]
			    [:a {:href "#"} "Delete"]]]}
	  :left {:content [[:img {:src (:image book) :width "80"}]]}]])

      (defn book-grid-component [books]
	(into
	 [:div.columns.is-multiline]
	 (for [b books]
	   [book-component b])))

      (paginate data book-grid-component)

    #+end_src

** Toolbars

*** The deftoolbar-item Function

    The ~deftoolbar-item~ function is used to define the ~map~ used to represent
    a toolbar item. The map is very simple and only supports three keys

    - :type :: A hiccup tag or reagent component name. The content will be
      wrapped in this element. Defaults to ~:div~.
    - :class :: Any additional class attributes to add to the wrapping element
    - :content :: The actual conent for this item. Can be any valid hiccup or
      reagent component, 

*** The toolbar Component

    The ~toolbar~ component provides a basic horizontal ~toolbar~ which can be
    used at the top of pages to provide in-page navigation. The component accepts
    a ~map~ as the only argument. This map must contain at least the
    ~:left-items~ key. The ~:right-tiems~ and ~:class~ keys are optional.

   - :let-items :: A vector of toolbar item maps. These maps are created by the
     ~:deftoolbar-item~ function.
   - :right-items :: A vector of toolbar item maps which are placed to the right
     of the ~:left-items~ in the toolbar
   - :class :: Any additional class atttriutes to add to the toolbar
 
** Sidebar

   The ~sidebar~ component provides a basic vertical menu sidebar. Menu choices
   are recorded in the global session atom. Items in the sidebar can be simple
   menu choices (links) or nested menus. 

*** The defsidebar-item Function

    The ~defsidebar-item~ function is used to define the ~map~ used to represent
    sidebar menu items. It supports the following keyname argumentds

    - :type :: The type of the item, either ~:item~, representing a simple menu
      link item or ~:menu~, representing a menu item with sub-menu links. The
      default is ~:item~. 
    - :title :: Either the menu title (if ~:type~ is ~:menu~) or the /name/
      (text) to be used in the menu.
    - :href :: For menu items, this is the ~href~ attribute for the link. The
      default is ~#~.
    - :icon-image :: An icon image to be associated with the menu entry.
    - :id :: The ~id~ attribute to be added to this element. If not provided, a
      unique default value with a prefix of ~side-bar-~ will be used.
    - :items :: In the case where the ~:type~ is ~:menu~, this key contains a
      vector of ~defsidebar-item~ maps representing sub-menu entries.
    - :class :: Any additional class attriutes to add to the enclosing element

*** The sidebar Component 

    The ~sidebar~ component will display a vertical menu on the page. The
    sidebar is defined via a ~map~, which is created using the ~defsidebar-item~
    function. The component expects a ~map~ with the following keys

    - :session-key :: A path into the global session atom where this component
      instance will record menu choices
    - :default-link :: The ~id~ of the default link to set as active when the
      sidebar is first loaded
    - :item :: The /parent/ menu item. A ~map~ defined using ~defsidebar-item~
      representing the parent (head) of the sidebar. This value will have a
      vector of additional ~defsidebar-item~ maps representing menu and sub-menu
      links in the sidebar.
 
* Technical Notes

A main objective of the components is to provide flexibility with reasonable
defaults. In particular, separating the defining data from the component
implementation was considered important. The general idea was to be able to
define more complex components as a ~var~ and pass that definition to the
componets when they need to be rendered. Ultimately, the objective is to define
a simple UI generator that would provide a consistent and fast way to define the
basic /shape/ of the user interface and allow that definition to later be
tweaked to meet specific requirements. 

Components are defined to keep internal /housekeeping/ information in a state
atom local to each component. Public i.e. data or information that will be
reuired by the application is placed in a central state atom managed using the
~reagent.session~ namespace. When a component has such public data, the
component requires a ~session-key~, which is a path into the global state atom
(a clojure ~map~) that will be used by that component to store whatever public
data is creates/manages. 

Many elements which make up a component can be thought of as sub-components
(e.g. menus, search boxes etc). Often, these components will require a unique
element Id. While it is possible to define the Id as part of the item
definition, any item which is not supplied with an Id will have one
automatically generated. This will work for internal housekeeping purposes, but
if the ID is required by external components, it will be necessary to specify it
manually when defining the item. 

** Menus, Nabvars, Sidebars and Toolbars

   Many of the components represent a UI element which the user interacts with,
   such as selecting menu items or navigating to specific application pages. In
   order to track which items have been selected by the user, these components
   use the ~reagent-session~ library to maintain a global session atom. 

   When defining a navbar, toolbar, sidebar or menu, you specify a
   ~:session-key~. This is a path key into the global session atom managed by
   ~reagent.sessin~. Each component will add a ~:choice~ key to this path that
   contains the ~id~ of the active menu selection. 

   Most components allow you to set a ~:default-link~, which is the ~id~ of the
   default item within the component. If a ~:default-link~ is defined, that link
   will be marked as /active/ when the component is first loaded. This typically
   means the associated link or menu item is highlighted.  
