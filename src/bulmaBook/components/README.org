* Components

** Navbars

*** Defining Navbar Items

    A navbar consists of a number of elements (brand, menus etc). To assist in
    defining these elements, the function ~defnavbar-item~ is provided. This
    function generates a map which the ~navbar~ component knows how to process
    in order to generate the HTML and Javascript for the component. 

    A navbar item is a map which can contain the following keys. The only
    required keys are ~:type~ and ~:contents~. 

    - :type :: The type of the item. Valid types are
	- *:a* Item contents are wrapped in an ~<a>~ element. Default
	- *:div* Item contents are wrapped in a ~<div>~ element
	- *:dropdown* Item contents represent a dropdown menu and are wrapped
          as a dropdown menu element
	- *:raw* Item contents are not wrapped in any elmeent. Just added 'as
          is'.


    - :title :: The title to use for dropdown menus (i.e. parent menu title)
    - :class :: Any additional classes to add to the element i.e. tweak CSS
      styles.
    - :href :: For link elements, the ~href~ target. Defaults to ~#~
    - :id :: Element Id. If not specified, a unique Id will be automatically
      generated with the prefix ~nav-~
    - :contents :: The item content. The value of this key will depend on the
      type of item.
	- *:a* The anchor text
	- *:raw* Value is simply wrapped in a ~<div>~ element
	- *:div* Vector of item maps generated by ~defnavbar-item~
	- *:dropdown* Vecotr of item maps defining dropdown menu items
          generated by ~defnavbar-item~.


    - :selectable :: True if the item should have a click handler associated
      with it. Default is true.
    - :icon-image :: Local path to an icon image to be added to the item
    - :is-hoverable :: For dropdown menus, adds the hoverable class to enable
      the menu to dropdown when mouse hovers over parent link 

*** The Navbar Component

   The navbar is an application navigaton bar to appear at the top of the
   rendered page. It consists of an (pitonal) brand and application menus and 
   possibly other items, such as a search box or static text. the navbar can be
   definined to have a shadow effect and be either a light or dark colour. A
   /burger/ menus is also supported, which will be displayed on mobile and table
   screens. Clicking the burger will then list the menus vertically on small
   screen devices. 

   When a navbar menu choice is made, the ~id~ of the chosen item is put into
   the session state atom under the key ~:choice~ within the map referenced by
   the ~:sesson-key~ value. 

   Menus can be regular single item menu links or dropdown menus. The function
   ~defnavbar-item` can be used to define menu items. 

   The basic idea behind the navbar is that it can be defined as pure data, in a
   map which consists of the following keys.

   - :session-key :: this is a path into the session state atom and used by the
     navbar component to record /public/ information which may be used by other
     pats of the application e.g. menu choices, current page etc. The global
     session state is managed by the ~reagent-session~ library.
   - :has-shadow :: True if the navbar should have a shadow effect. Defaults to
     true
   - :is-dark :: True if the navbar should be rendered in a dark colour. False
     by default
   - :has-burger :: True if the navbar has a burger menu which is displayed on
     small screens. Default is true.
   - :class :: Additional classes to add to the ~<nav>~ element
   - :default-link :: The Id of the defualt menu link to mark as active when the
     navbar is first loaded
   - :brand :: A map created by ~defnavbar-item~ representing the navbar brand
     element
   - :menus :: A vector of ~defnavbar-item~ maps representing the main menu
     elements
   - :end-menu :: A vector of ~defnavbar-item~ items defining menus to be added
     to the right of the main menus in the navbar 

*** Example Navbar

    An exmaple navbar 

    #+begin_src clojure
      (ns example.app.core
	(:require [bulmaBook.components.navbar :refer :all]))

      (def navbar-data
	{:session-key [:main-navbar]
	 :has-shadow true
	 :class "is-dark"
	 :default-link :home
	 :has-burger true
	 :brand (defnavbar-item
		  :contents [:img {:src "images/logo.png"}])
	 :menus [(defnavbar-item
		   :type :div
		   :contents
		   [(defnavbar-item
		      :type :raw
		      :contents [:small "Publishing at the speed of technology"])])
		 (defnavbar-item
		   :contents "Home"
		   :id :home)]
	 :end-menu [(defnavbar-item
		      :type :dropdown
		      :title "Alex Johnson"
		      :is-hoverable true
		      :contents [(defnavbar-item :id :profile :contents "Profile"
				   :icon-img "fa-user-circle-o")
				 (defnavbar-item :id :report-bug
				   :contents "Report Bug" :icon-img "fa-bug")
				 (defnavbar-item :id :sign-out :contents "Sign Out"
				   :icon-img "fa-sign-out")])]})

      (navbar navbar-data)

    #+end_src

** Page pagination

   The ~paginate~ component provides a simple pagination function to help
   display long lists of records. Records will be partitioned into groups of
   /pages/ with a simple navigation header allowing movement forward/back and
   selection of specific pages from the list. 

   The component has two mandatory arguments, ~records~ and ~page-render-fn~ and
   three optional named arguments.

   - records :: A sequence of individual records to be displayed in the pages
   - page-render-fn :: The function used to display each record. I should accept
     one argument, the record to display. This is typically a ~Reagent~
     component used to render the record.
   - :page-size :: The number of records to display on each page. Default 10.
   - :is-rounded :: If true, navigation elements have rounded corners. Default
     false
   - :button-size :: Set the size of navigation buttons. May be ~:small~,
     ~:medium~ or ~:large~.

*** Example

    Example of simple pagination.

    #+begin_src clojure
      (ns example.app.core
	(:require [bulmaBook.components.paginate :refer :all]))

      (def data [{:title "TensorFlow For Machine Intelligence"
		  :image "images/tensorflow.jpg"
		  :cost "$22.99"
		  :pages 270
		  :isbn "9781939902351"}
		 {:title "Docker in Production"
		  :image "images/docker.jpg"
		  :cost "$22.99"
		  :pages 156
		  :isbn "9781939902184"}
		 {:title "Developing a Gulp.js Edge"
		  :image "images/gulp.jpg"
		  :cost "$22.99"
		  :pages 134
		  :isbn "9781939902146"}
		 {:title "Learning Swift”"
		  :image "images/swift.jpg"
		  :cost "$22.99"
		  :pages 342
		  :isbn "9781939902115"}
		 {:title "Choosing a JavaScript Framework"
		  :image "images/js-framework.jpg"
		  :cost "19.99"
		  :pages 96
		  :isbn "9781939902092"}
		 {:title "Deconstructing Google Cardboard Apps"
		  :image "images/google-cardboard.jpg"
		  :cost "$22.99"
		  :pages 179
		  :isbn "9781939902092245"}])

      (defn book-component [book]
	[:article.box
	 [media {:content [[:p.title.is-5.is-spaced.is-marginless
			    [:a {:href "#"} (:title book)]]
			   [:p.subtitle.is-marginless (:price book)]
			   [:div.content.is-small
			    (str (:pages book) " pages")
			    [:br]
			    (str "ISBN: " (:isbn book))
			    [:br]
			    [:a {:href "#"} "Edit"]
			    [:span "·"]
			    [:a {:href "#"} "Delete"]]]}
	  :left {:content [[:img {:src (:image book) :width "80"}]]}]])

      (defn book-grid-component [books]
	(into
	 [:div.columns.is-multiline]
	 (for [b books]
	   [book-component b])))

      (paginate data book-grid-component)

    #+end_src

* Technical Notes

A main objective of the components is to provide flexibility with reasonable
defaults. In particular, separating the defining data from the component
implementation was considered important. The general idea was to be able to
define more complex components as a ~var~ and pass that definition to the
componets when they need to be rendered. Ultimately, the objective is to define
a simple UI generator that would provide a consistent and fast way to define the
basic /shape/ of the user interface and allow that definition to later be
tweaked to meet specific requirements. 

Components are defined to keep internal /housekeeping/ information in a state
atom local to each component. Public i.e. data or information that will be
reuired by the application is placed in a central state atom managed using the
~reagent.session~ namespace. When a component has such public data, the
component requires a ~session-key~, which is a path into the global state atom
(a clojure ~map~) that will be used by that component to store whatever public
data is creates/manages. 

Many elements which make up a component can be thought of as sub-components
(e.g. menus, search boxes etc). Often, these components will require a unique
element Id. While it is possible to define the Id as part of the item
definition, any item which is not supplied with an Id will have one
automatically generated. This will work for internal housekeeping purposes, but
if the ID is required by external components, it will be necessary to specify it
manually when defining the item. 
