* Components

** Navbars

*** Defining Navbar Items

    A navbar consists of a number of elements (brand, menus etc). To assist in
    defining these elements, the function ~defnavbar-item~ is provided. This
    function generates a map which the ~navbar~ component knows how to process
    in order to generate the HTML and Javascript for the component. 

    A navbar item is a map which can contain the following keys. The only
    required keys are ~:type~ and ~:contents~. 

    - :type :: The type of the item. Valid types are
	- :a :: Item contents are wrapped in an ~<a>~ element. Default
	- :div :: Item contents are wrapped in a ~<div>~ element
	- :dropdown :: Item contents represent a dropdown menu and are wrapped
          as a dropdown menu element
	- :raw :: Item contents are not wrapped in any elmeent. Just added 'as
          is'.
    - :title :: The title to use for dropdown menus (i.e. parent menu title)
    - :class :: Any additional classes to add to the element i.e. tweak CSS
      styles.
    - :href :: For link elements, the ~href~ target. Defaults to ~#~
    - :id :: Element Id. If not specified, a unique Id will be automatically
      generated with the prefix ~nav-~
    - :contents :: The item content. The value of this key will depend on the
      type of item.
	- :a :: The anchor text
	- :raw :: Value is simply wrapped in a ~<div>~ element
	- :div :: Vector of item maps generated by ~defnavbar-item~
	- :dropdown :: Vecotr of item maps defining dropdown menu items
          generated by ~defnavbar-item~.
    - :selectable :: True if the item should have a click handler associated
      with it. Default is true.
    - :icon-image :: Local path to an icon image to be added to the item
    - :is-hoverable :: For dropdown menus, adds the hoverable class to enable
      the menu to dropdown when mouse hovers over parent link 

*** The Navbar Component

   The navbar is an application navigaton bar to appear at the top of the
   rendered page. It consists of an (pitonal) brand and application menus and 
   possibly other items, such as a search box or static text. the navbar can be
   definined to have a shadow effect and be either a light or dark colour. A
   /burger/ menus is also supported, which will be displayed on mobile and table
   screens. Clicking the burger will then list the menus vertically on small
   screen devices. 

   Menus can be regular single item menu links or dropdown menus. The function
   ~defnavbar-item` can be used to define menu items. 

   The basic idea behind the navbar is that it can be defined as pure data, in a
   map which consists of the following keys.

   - :session-key :: this is a path into the session state atom and used by the
     navbar component to record /public/ information which may be used by other
     pats of the application e.g. menu choices, current page etc. The global
     session state is managed by the ~reagent-session~ library.
   - :has-shadow :: True if the navbar should have a shadow effect. Defaults to
     true
   - :is-dark :: True if the navbar should be rendered in a dark colour. False
     by default
   - :has-burger :: True if the navbar has a burger menu which is displayed on
     small screens. Default is true.
   - :class :: Additional classes to add to the ~<nav>~ element
   - :default-link :: The Id of the defualt menu link to mark as active when the
     navbar is first loaded
   - :brand :: A map created by ~defnavbar-item~ representing the navbar brand
     element
   - :menus :: A vector of ~defnavbar-item~ maps representing the main menu
     elements
   - :end-menu :: A vector of ~defnavbar-item~ items defining menus to be added
     to the right of the main menus in the navbar 


*** Example Navbar

    An exmaple navbar 

    #+begin_src clojure
      (def navbar-data
	{:session-key [:main-navbar]
	 :has-shadow true
	 :class "is-dark"
	 :default-link :home
	 :has-burger true
	 :brand (defnavbar-item
		  :contents [:img {:src "images/logo.png"}])
	 :menus [(defnavbar-item
		   :type :div
		   :contents
		   [(defnavbar-item
		      :type :raw
		      :contents [:small "Publishing at the speed of technology"])])
		 (defnavbar-item
		   :contents "Home"
		   :id :home)]
	 :end-menu [(defnavbar-item
		      :type :dropdown
		      :title "Alex Johnson"
		      :is-hoverable true
		      :contents [(defnavbar-item :id :profile :contents "Profile"
				   :icon-img "fa-user-circle-o")
				 (defnavbar-item :id :report-bug
				   :contents "Report Bug" :icon-img "fa-bug")
				 (defnavbar-item :id :sign-out :contents "Sign Out"
				   :icon-img "fa-sign-out")])]})

      (navbar navbar-data)

    #+end_src


* Technical Notes

A main objective of the components is to provide flexibility with reasonable
defaults. In particular, separating the defining data from the component
implementation was considered important. The general idea was to be able to
define more complex components as a ~var~ and pass that definition to the
componets when they need to be rendered. Ultimately, the objective is to define
a simple UI generator that would provide a consistent and fast way to define the
basic /shape/ of the user interface and allow that definition to later be
tweaked to meet specific requirements. 

Components are defined to keep internal /housekeeping/ information in a state
atom local to each component. Public i.e. data or information that will be
reuired by the application is placed in a central state atom managed using the
~reagent.session~ namespace. When a component has such public data, the
component requires a ~session-key~, which is a path into the global state atom
(a clojure ~map~) that will be used by that component to store whatever public
data is creates/manages. 

Many elements which make up a component can be thought of as sub-components
(e.g. menus, search boxes etc). Often, these components will require a unique
element Id. While it is possible to define the Id as part of the item
definition, any item which is not supplied with an Id will have one
automatically generated. This will work for internal housekeeping purposes, but
if the ID is required by external components, it will be necessary to specify it
manually when defining the item. 
